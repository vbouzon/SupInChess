///////////////////////////////////////////////////////////
//  BasePiece.cs
//  Implementation of the Class BasePiece
//  Generated by Enterprise Architect
//  Created on:      08-déc.-2008 15:47:35
//  Original author: Vincent
///////////////////////////////////////////////////////////

#region usings

using System;
using System.Collections.Generic;
using ChessLib.Actions;

#endregion

namespace ChessLib.Pieces
{
    ///<summary>
    ///
    ///</summary>
    public abstract class BasePiece
    {
        ///<summary>
        ///
        ///</summary>
        protected readonly PieceColor _color;

        ///<summary>
        ///
        ///</summary>
        protected readonly Game _parentGame;

        ///<summary>
        ///
        ///</summary>
        protected PiecePosition _currentPosition;

        ///<summary>
        ///
        ///</summary>
        protected int _movementsCount;

        ///<summary>
        ///
        ///</summary>
        protected List<Func<BasePiece, MoveAction>> _movementsFunctions;


        ///<summary>
        ///
        ///</summary>
        ///<param name="position"></param>
        ///<param name="color"></param>
        ///<param name="parentGame"></param>
        protected BasePiece(Game parentGame, PiecePosition position, PieceColor color)
        {
            this._currentPosition = position;
            this._color = color;
            this._parentGame = parentGame;
            this._movementsFunctions = new List<Func<BasePiece, MoveAction>>();
        }

        ///<summary>
        ///Return la position actuelle de la pièce.
        ///</summary>
        public PiecePosition Position
        {
            get { return this._currentPosition; }
        }

        ///<summary>
        ///Retourne la liste des nouvelles positions possible après mouvement.
        ///</summary>
        public Dictionary<PiecePosition, MoveAction> AvailableMovements
        {
            get
            {
                var piecesMovements = new Dictionary<PiecePosition, MoveAction>();

                foreach (var movementFunction in this._movementsFunctions)
                {
                    MoveAction pieceMovement = movementFunction(this);

                    if (pieceMovement == null)
                    {
                        continue;
                    }

                    //Teste si la position de destination est sur le tableau.
                    if (this._parentGame.Board.IsAvailablePosition(pieceMovement.ArrivalPosition) == false)
                    {
                        continue;
                    }

                    //Teste si la case de destination est occupé par une piece de sa propre couleur.
                    BasePiece otherPiece = this._parentGame.Board.GetPiece(pieceMovement.ArrivalPosition);
                    if (otherPiece != null && otherPiece.Color == this.Color)
                    {
                        continue;
                    }

                    //Si tout est bon, on ajoute.
                    piecesMovements.Add(pieceMovement.ArrivalPosition, pieceMovement);
                }

                return piecesMovements;
            }
        }

        ///<summary>
        ///Retourne le tableau auquel appartient la pièce.
        ///</summary>
        public Game ParentGame
        {
            get { return this._parentGame; }
        }

        ///<summary>
        ///Retourne la couleur de la pièce.
        ///</summary>
        public PieceColor Color
        {
            get { return this._color; }
        }

        ///<summary>
        ///
        ///</summary>
        public int MovementCount
        {
            get { return this._movementsCount; }
            set { this._movementsCount = value; }
        }

        ///<summary>
        ///
        ///</summary>
        ///<param name="newPosition"></param>
        ///<returns></returns>
        public MoveAction GetMove(PiecePosition newPosition)
        {
            Dictionary<PiecePosition, MoveAction> availableMovements = this.AvailableMovements;

            if (availableMovements.ContainsKey(newPosition) == false)
            {
                return null;
            }

            if (availableMovements[newPosition] as SimpleMoveAction != null)
            {
                ((SimpleMoveAction) availableMovements[newPosition]).VerifyMovement = false;
            }

            if (this._parentGame.ActionsManager.Do(availableMovements[newPosition]) == false)
            {
                return null;
            }

            bool playerIsChess = this._parentGame.GetPlayer(this._color).IsChess;

            this._parentGame.ActionsManager.UnDo();

            return playerIsChess ? null : availableMovements[newPosition];
        }

        ///<summary>
        ///
        ///</summary>
        ///<param name="newPosition"></param>
        ///<returns></returns>
        public bool CanMove(PiecePosition newPosition)
        {
            return this.GetMove(newPosition) != null;
        }

        ///<summary>
        ///
        ///</summary>
        ///<param name="newPosition"></param>
        ///<param name="verifyMovement"></param>
        ///<returns></returns>
        /// <exception cref="ArgumentNullException"><c>newPosition</c> is null.</exception>
        public bool Move(PiecePosition newPosition, bool verifyMovement)
        {
            if (verifyMovement && this.CanMove(newPosition) == false)
            {
                return false;
            }

            BasePiece piece = this._parentGame.Board.GetPiece(newPosition);

            if (piece != null && this._color != piece.Color)
            {
                if (this._parentGame.ActionsManager.Do(new DeleteAction(this._parentGame, newPosition)) == false)
                {
                    return false;
                }
            }

            this._currentPosition = newPosition;

            return true;
        }
    }
}